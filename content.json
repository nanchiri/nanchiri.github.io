{"meta":{"title":"伊藤三叶的博客","subtitle":"","description":"伊藤三叶的博客","author":"Ye Zhenglin","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"最长子串","slug":"最长子串","date":"2020-06-08T08:28:02.000Z","updated":"2020-06-08T08:34:44.414Z","comments":true,"path":"2020/06/08/最长子串/","link":"","permalink":"http://yoursite.com/2020/06/08/%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"#题目给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 示例: 输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 #解题思路与代码public int longestConsecutive(int[] nums) { Set num_set = new HashSet(); for (int num : nums) { num_set.add(num); } int longestStreak = 0; for (int num : num_set) { if (!num_set.contains(num - 1)) { int currentNum = num; int currentStreak = 1; while (num_set.contains(currentNum + 1)) { currentNum += 1; currentStreak += 1; } longestStreak = Math.max(longestStreak, currentStreak); } } return longestStreak; } #参考文献链接：https://leetcode-cn.com/problems/longest-consecutive-sequence","categories":[],"tags":[]},{"title":"打家劫舍","slug":"leetcode2-0","date":"2020-06-03T02:59:26.000Z","updated":"2020-06-03T04:03:05.704Z","comments":true,"path":"2020/06/03/leetcode2-0/","link":"","permalink":"http://yoursite.com/2020/06/03/leetcode2-0/","excerpt":"","text":"#题目 /*打家劫舍 经典动态规划题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。示例 2: 输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 #思路 由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值 动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num ) 举例来说：1 号房间可盗窃最大值为 33 即为 dp[1]=3，2 号房间可盗窃最大值为 44 即为 dp[2]=4，3 号房间自身的值为 22 即为 num=2，那么 dp[3] = MAX( dp[2], dp[1] + num ) = MAX(4, 3+2) = 5，3 号房间可盗窃最大值为 55 #参考代码 public int rob(int[] nums) { int length = nums.length; int[] dp = new int[length + 1]; dp[0] = 0; dp[1] = nums[0]; for (int i = 2; i &lt;= length; i++) { // dp[i] = (dp[i - 1] &gt;= dp[i - 2] + nums[i - 1] ? dp[i - 1] : dp[i - 2] + nums[i - 1]); } return dp[length]; }","categories":[],"tags":[]},{"title":"五一摸鱼题leetcode21合并两个有序链表","slug":"leetcode21合并两个有序链表","date":"2020-05-01T01:05:50.000Z","updated":"2020-05-01T01:19:05.439Z","comments":true,"path":"2020/05/01/leetcode21合并两个有序链表/","link":"","permalink":"http://yoursite.com/2020/05/01/leetcode21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","excerpt":"","text":"#题目 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 #解题思路（一）暴力迭代遍历两个链表，然后合并即可。(二)递归在l1或l2不为空时，判断l1和l2的头节点大小，接着递归决定下一个添加到结果里的节点；如果有一个链表空了，递归结束。 #参考代码(一)class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { int num=0,g=0; num+=func1(l1)+func1(l2); int arr[]=new int[num]; while (l1!=null){ arr[g++]=l1.val; l1=l1.next; } while (l2!=null){ arr[g++]=l2.val; l2=l2.next; } if (arr.length==0)return null; quickSort(arr,0,arr.length-1);//自己写一个快速排序⑧ ListNode listNode=new ListNode(arr[0]); ListNode head=listNode; for (int i = 1; i &lt; arr.length; ++i) { listNode.next=new ListNode(arr[i]); listNode=listNode.next; } return head; } public int func1(ListNode l1){ int ans=0; while (l1!=null){ ans++; l1=l1.next; } return ans; }(二)class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } else if (l2 == null) { return l1; } else if (l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } }} 参考文献https://leetcode-cn.com/problems/merge-two-sorted-lists/","categories":[],"tags":[]},{"title":"leetcode200 岛屿数量","slug":"Leetcode3","date":"2020-04-20T08:04:11.000Z","updated":"2020-04-20T08:54:34.305Z","comments":true,"path":"2020/04/20/Leetcode3/","link":"","permalink":"http://yoursite.com/2020/04/20/Leetcode3/","excerpt":"","text":"#题目给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。Input:[[[‘1’,’1’,’1’,’1’,’0’],[‘1’,’1’,’0’,’1’,’0’],[‘1’,’1’,’0’,’0’,’0’],[‘0’,’0’,’0’,’0’,’0’]]]Output:1 #解法（bfs就不写咯）线性扫描整个二维网络，如果一个节点为’1’，则以其为根据点启动dfs,搜索过程中访问过的节点赋值为’0’，计数dfs的根节点数量，即为岛屿的数量。 #代码public int numIslands(char[][] grid) { int ans=0; for (int i = 0; i &lt; grid.length; ++i) { for (int j = 0; j &lt; grid[i].length; j++) { if (grid[i][j]==’1’){ ans++; dfs(grid,i,j); } } } return ans; } public static void dfs(char[][]grid,int row ,int col){ if (row&lt;0||col&lt;0||row&gt;=grid.length||col&gt;=grid[0].length||grid[row][col]==’0’) return; dfs(grid,row+1,col); dfs(grid, row-1, col); dfs(grid, row, col+1); dfs(grid, row, col-1); } — #参考文献 https://leetcode-cn.com/problems/number-of-islands/","categories":[],"tags":[]},{"title":"leetcode 打家劫舍 经典动态规划","slug":"leetcod4","date":"2020-04-20T08:04:11.000Z","updated":"2020-05-29T13:41:23.136Z","comments":true,"path":"2020/04/20/leetcod4/","link":"","permalink":"http://yoursite.com/2020/04/20/leetcod4/","excerpt":"","text":"#题目打家劫舍 经典动态规划题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。示例 2: 输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 #解题思路由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值 动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num )举例来说：1 号房间可盗窃最大值为 33 即为 dp[1]=3，2 号房间可盗窃最大值为 44 即为 dp[2]=4，3 号房间自身的值为 22 即为 num=2，那么 dp[3] = MAX( dp[2], dp[1] + num ) = MAX(4, 3+2) = 5，3 号房间可盗窃最大值为 55 #代码 public int rob(int[] nums) { int length=nums.length; int[] dp=new int[length+1]; dp[0] = 0; dp[1]=nums[0]; for (int i = 2; i &lt;=length ;i++) { // dp[i]=(dp[i-1]&gt;=dp[i-2]+nums[i-1]?dp[i-1]:dp[i-2]+nums[i-1]); } return dp[length]; }","categories":[],"tags":[]},{"title":"leetcode289","slug":"博客测试","date":"2020-04-18T08:12:11.000Z","updated":"2020-04-20T08:01:14.739Z","comments":true,"path":"2020/04/18/博客测试/","link":"","permalink":"http://yoursite.com/2020/04/18/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/","excerpt":"","text":"#题目给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律： 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；如果死细胞周围正好有三个活细胞，则该位置死细胞复活；根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。 input:[ [0,1,0], [0,0,1], [1,1,1], [0,0,0]]output:[ [0,0,0], [1,0,1], [0,1,1], [0,1,0]] #解题思路 使用原地算法，一般就会牵涉到编解码问题。（第一次遇到编码解码方法做题目，特此记录）题目意思是说： &lt; 2 live -&gt;dead 2 or 3 live-&gt;live 3 live-&gt;dead 3 dead-&gt;live 所以，统计八个方位的存活细胞数目（原地更新）： 死细胞，周围存活细胞数=3，复活dead-&gt;live。 活细胞，周围存活细胞数&lt;2 or &gt;3，死掉live-&gt;dead。 但是原地更新，肯定不能用0和1更新board[ ][ ]，因为会破会下一次循环计算。 可以使用3表示由死变活 3—活（解码时，3用1替换） 可以使用2表示由活变死 2—死（解码时，2用0替换） 所以，board[ ] [ ]中1和3都是live，0和2都是dead。那么，每次最末尾的时候都需要一次解码过程，也就是将3-&gt;1和2-&gt;0才符合题意。 #参考代码public void gameOfLife(int[][] board) {// 若数组为null 则return if (board == null || board[0] == null) return; int rows = board.length, cols = board[0].length; for (int i = 0; i &lt; rows; i++) { for (int j = 0; j &lt; cols; j++) {// 活细胞数 int countlive = 0;// 统计当前细胞周围八个位置的活细胞状态 if (i - 1 &gt;= 0 &amp;&amp; (board[i - 1][j] == 2 || board[i - 1][j] == 1)) { countlive += 1; } //右上 if (i - 1 &gt;= 0 &amp;&amp; j + 1 &lt; cols &amp;&amp; (board[i - 1][j + 1] == 1 || board[i - 1][j + 1] == 2)) { countlive += 1; } //右 if (j + 1 &lt; cols &amp;&amp; (board[i][j + 1] == 1 || board[i][j + 1] == 2)) { countlive += 1; } //右下 if (i + 1 &lt; rows &amp;&amp; j + 1 &lt; cols &amp;&amp; (board[i + 1][j + 1] == 1 || board[i + 1][j + 1] == 2)) { countlive += 1; } //下 if (i + 1 &lt; rows &amp;&amp; (board[i + 1][j] == 1 || board[i + 1][j] == 2)) { countlive += 1; } //左下 if (i + 1 &lt; rows &amp;&amp; j - 1 &gt;= 0 &amp;&amp; (board[i + 1][j - 1] == 1 || board[i + 1][j - 1] == 2)) { countlive += 1; } //左 if (j - 1 &gt;= 0 &amp;&amp; (board[i][j - 1] == 1 || board[i][j - 1] == 2)) { countlive += 1; } //左上 if (j - 1 &gt;= 0 &amp;&amp; i - 1 &gt;= 0 &amp;&amp; (board[i - 1][j - 1] == 1 || board[i - 1][j - 1] == 2)) { countlive += 1; } if (board[i][j] == 0 &amp;&amp; countlive == 3) //更新–如果死细胞周围正好有三个活细胞，则该位置死细胞复活 //3表示由死变活 3—活 board[i][j] = 3; if (board[i][j] == 1) if (countlive &lt; 2 || countlive &gt; 3) board[i][j] = 2; } } for (int i = 0; i &lt; rows; i++) { for (int j = 0; j &lt; cols; j++) { board[i][j] = board[i][j] % 2; } } } #参考文献 https://leetcode-cn.com/problems/game-of-life/","categories":[],"tags":[]},{"title":"leetcode8","slug":"Leetcode2","date":"2020-04-18T08:12:11.000Z","updated":"2020-04-19T01:41:10.457Z","comments":true,"path":"2020/04/18/Leetcode2/","link":"","permalink":"http://yoursite.com/2020/04/18/Leetcode2/","excerpt":"","text":"#题目请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 提示： 本题中的空白字符只包括空格字符 ‘ ‘ 。假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) #代码+注释 public int myAtoi(String str) {//去除空格 str = str.trim(); if (str.length() == 0) return 0;/假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。/ if (!Character.isDigit(str.charAt(0)) &amp;&amp; str.charAt(0) != ‘-‘ &amp;&amp; str.charAt(0) != ‘+’) return 0; long ans = 0L;// neg判断是否为负数 boolean neg = str.charAt(0) == ‘-‘; /* * 如果第一个字符不为数字 则i从1开始 否则从0开始 * 循环会在达到字符串长度或者索引字符不为数字时停止*/ for (int i = !Character.isDigit(str.charAt(0)) ? 1 : 0; i &lt; str.length() &amp;&amp; Character.isDigit(str.charAt(i)); ) { ans = ans * 10 + (str.charAt(i++) - ‘0’); if (!neg &amp;&amp; ans &gt; Integer.MAX_VALUE) { ans = Integer.MAX_VALUE; break; } if (neg &amp;&amp; ans &gt; 1L + Integer.MAX_VALUE) { ans = Integer.MAX_VALUE + 1L; break; } } return neg ? (int) -ans : (int) ans; }","categories":[],"tags":[]}],"categories":[],"tags":[]}